<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rubik 3D Interactivo</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            margin: 0;
            background: linear-gradient(145deg, #0a0a0a, #1a1a1a);
            color: white;
            font-family: 'Segoe UI', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }

        canvas {
            width: 600px;
            height: 600px;
            box-shadow: 0 20px 50px rgba(0, 255, 255, 0.2);
        }

        #controls {
            margin-top: 1rem;
        }

        .rubik-btn {
            margin: 0.25rem;
        }

        #tutorial {
            background: #212529;
            padding: 1rem;
            border-radius: 10px;
            margin-top: 1rem;
            max-width: 600px;
        }

        .step {
            margin-bottom: 0.5rem;
        }

        .highlight {
            color: #0dcaf0;
        }
    </style>
</head>

<body>
    <canvas id="rubikCanvas"></canvas>
    <div id="controls" class="text-center">
        <button class="btn btn-outline-info rubik-btn" onclick="rotateFace('U')">U</button>
        <button class="btn btn-outline-info rubik-btn" onclick="rotateFace('Ui')">U'</button>
        <button class="btn btn-outline-info rubik-btn" onclick="rotateFace('R')">R</button>
        <button class="btn btn-outline-info rubik-btn" onclick="rotateFace('Ri')">R'</button>
        <button class="btn btn-outline-info rubik-btn" onclick="rotateFace('F')">F</button>
        <button class="btn btn-outline-info rubik-btn" onclick="rotateFace('Fi')">F'</button>
    </div>
    <div id="tutorial" class="text-light">
        <h3>Tutorial para resolver el cubo:</h3>
        <div class="step">1. Cruz blanca: <span class="highlight">F R U Ri Ui Fi</span></div>
        <div class="step">2. Esquinas blancas: <span class="highlight">Ri Di R D</span> hasta encajar</div>
        <div class="step">3. Segunda capa: <span class="highlight">U R Ui Ri Ui Fi U F</span></div>
        <div class="step">4. Cruz amarilla: <span class="highlight">F R U Ri Ui Fi</span></div>
        <div class="step">5. Orientar cruz: <span class="highlight">R U Ri U R U U Ri</span></div>
        <div class="step">6. Esquinas amarillas: <span class="highlight">U R Ui Li U Ri Ui L</span></div>
        <div class="step">7. Colocar esquinas: <span class="highlight">R U Ri U R U U Ri</span></div>
    </div>

    <script>
        const canvas = document.getElementById('rubikCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;

        let angleX = 0.6;
        let angleY = 0.8;
        let orbit = 0;
        const size = 60;
        const cube = [];

        for (let x = -1; x <= 1; x++) {
            for (let y = -1; y <= 1; y++) {
                for (let z = -1; z <= 1; z++) {
                    cube.push({ x, y, z });
                }
            }
        }

        let dragging = false;
        let lastX, lastY;

        canvas.addEventListener('mousedown', e => {
            dragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        });

        canvas.addEventListener('mouseup', () => dragging = false);
        canvas.addEventListener('mouseleave', () => dragging = false);

        canvas.addEventListener('mousemove', e => {
            if (dragging) {
                angleY += (e.clientX - lastX) * 0.01;
                angleX += (e.clientY - lastY) * 0.01;
                lastX = e.clientX;
                lastY = e.clientY;
            }
        });

        function rotate(point, axis, theta) {
            const sin = Math.sin(theta);
            const cos = Math.cos(theta);
            const [x, y, z] = [point.x, point.y, point.z];
            if (axis === 'x') {
                point.y = y * cos - z * sin;
                point.z = y * sin + z * cos;
            } else if (axis === 'y') {
                point.x = x * cos - z * sin;
                point.z = x * sin + z * cos;
            } else if (axis === 'z') {
                point.x = x * cos - y * sin;
                point.y = x * sin + y * cos;
            }
        }

        function rotateFace(face) {
            const theta = Math.PI / 2;
            const sel = [];

            cube.forEach(c => {
                if (face === 'U' && Math.abs(c.y - 1) < 0.1) sel.push(c);
                if (face === 'Ui' && Math.abs(c.y - 1) < 0.1) sel.push(c);
                if (face === 'R' && Math.abs(c.x - 1) < 0.1) sel.push(c);
                if (face === 'Ri' && Math.abs(c.x - 1) < 0.1) sel.push(c);
                if (face === 'F' && Math.abs(c.z - 1) < 0.1) sel.push(c);
                if (face === 'Fi' && Math.abs(c.z - 1) < 0.1) sel.push(c);
            });

            sel.forEach(c => {
                if (face === 'U') rotate(c, 'y', -theta);
                if (face === 'Ui') rotate(c, 'y', theta);
                if (face === 'R') rotate(c, 'x', -theta);
                if (face === 'Ri') rotate(c, 'x', theta);
                if (face === 'F') rotate(c, 'z', -theta);
                if (face === 'Fi') rotate(c, 'z', theta);
            });
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            const rotated = cube.map(c => {
                let x = c.x, y = c.y, z = c.z;
                [x, z] = [x * Math.cos(orbit) - z * Math.sin(orbit), x * Math.sin(orbit) + z * Math.cos(orbit)];
                [x, z] = [x * Math.cos(angleY) - z * Math.sin(angleY), x * Math.sin(angleY) + z * Math.cos(angleY)];
                [y, z] = [y * Math.cos(angleX) - z * Math.sin(angleX), y * Math.sin(angleX) + z * Math.cos(angleX)];
                return { x, y, z, original: c };
            });

            rotated.sort((a, b) => b.z - a.z);

            for (let c of rotated) {
                const x = cx + c.x * size;
                const y = cy + c.y * size;
                const grd = ctx.createLinearGradient(x, y, x + size / 2, y + size / 2);
                grd.addColorStop(0, '#00000055');
                grd.addColorStop(1, '#ffffff22');

                ctx.fillStyle = grd;
                ctx.fillRect(x - size / 2, y - size / 2, size - 4, size - 4);

                if (Math.abs(c.original.z - 1) < 0.1) ctx.fillStyle = 'red';
                else if (Math.abs(c.original.z + 1) < 0.1) ctx.fillStyle = 'orange';
                else if (Math.abs(c.original.x - 1) < 0.1) ctx.fillStyle = 'blue';
                else if (Math.abs(c.original.x + 1) < 0.1) ctx.fillStyle = 'green';
                else if (Math.abs(c.original.y - 1) < 0.1) ctx.fillStyle = 'white';
                else if (Math.abs(c.original.y + 1) < 0.1) ctx.fillStyle = 'yellow';
                else ctx.fillStyle = '#444';

                ctx.fillRect(x - size / 2 + 5, y - size / 2 + 5, size - 10, size - 10);
            }
        }

        function animate() {
            orbit += 0.0025;
            draw();
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>

</html>